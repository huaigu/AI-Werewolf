# AI-狼人杀架构概览

## 系统架构

AI-狼人杀是一个基于分布式 AI 的狼人杀游戏，采用 monorepo 实现，游戏主控和 AI 玩家服务之间有清晰的分离。

### 高层架构

```
┌─────────────────────────────────────────────────────────────┐
│                  游戏主控 (前端界面)                        │
│                        端口 3000                           │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │
│  │   React UI      │  │   MobX Store    │  │ GameMaster  │ │
│  │   组件库        │  │   (全局状态)    │  │   主控类    │ │
│  └─────────────────┘  └─────────────────┘  └─────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                │
                                │ HTTP API 调用
                                ▼
┌─────────────────────────────────────────────────────────────┐
│                    AI 玩家服务                              │
│      端口 3001-3008 (独立 AI 玩家)                         │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │
│  │ PlayerServer    │  │ AI Integration  │  │ Personality │ │
│  │ (Express API)   │  │ (OpenRouter)    │  │  个性系统   │ │
│  └─────────────────┘  └─────────────────┘  └─────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                │
                                │ AI API 调用
                                ▼
┌─────────────────────────────────────────────────────────────┐
│                      外部服务                               │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │
│  │   OpenRouter    │  │    Langfuse     │  │  OpenAI     │ │
│  │   (AI 代理)     │  │   (遥测系统)    │  │   模型      │ │
│  └─────────────────┘  └─────────────────┘  └─────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

## 核心组件

### 1. 游戏主控 (前端)

**位置**: `packages/game-master-vite/`

游戏主控作为狼人杀游戏的中心编排器和 UI 界面。

#### 主要职责：
- **游戏状态管理**: 使用 MobX 维护权威游戏状态
- **阶段控制**: 管理游戏流程 (夜晚 → 白天 → 投票 → 循环)
- **玩家编排**: 协调与 6-8 个 AI 玩家服务的通信
- **UI 渲染**: 提供实时游戏可视化和控制界面
- **角色分配**: 使用共享角色分配逻辑分发角色

#### 核心类：
- **GameMaster** (`lib/GameMaster.ts`): 中心游戏逻辑和状态
- **PlayerAPIClient** (`lib/PlayerAPIClient.ts`): 玩家通信的 HTTP 客户端
- **MobX Store** (`stores/gameStore.ts`): 响应式全局状态管理

### 2. AI 玩家服务 (后端)

**位置**: `packages/player/`

每个 AI 玩家都作为独立的 Express 服务器运行，具有自己的个性和决策逻辑。

#### 主要职责：
- **AI 决策制定**: 生成上下文相关的发言、投票和能力决策
- **个性系统**: 每个玩家都有独特的行为模式和策略
- **角色特定逻辑**: 处理狼人、预言家、女巫和村民的能力
- **上下文处理**: 分析游戏历史和当前状态进行决策
- **类型安全响应**: 所有 AI 输出使用 Zod 模式验证

#### 核心类：
- **PlayerServer** (`src/PlayerServer.ts`): 主服务器和 AI 编排器
- **PlayerConfig** (`src/config/PlayerConfig.ts`): 配置和个性管理
- **WerewolfPrompts** (`src/prompts/`): 角色和上下文特定的提示生成

### 3. 共享库

**位置**: `shared/`

整个系统中使用的通用工具和类型定义。

#### 主要模块：
- **类型** (`shared/types/`): TypeScript 接口和 Zod 模式
- **工具库** (`shared/lib/`): 角色分配、发言系统、操作日志
- **遥测** (`shared/lib/src/langfuse.ts`): AI 可观测性和监控

## 游戏流程架构

### 阶段管理

游戏遵循结构化的阶段系统，具有清晰的状态转换：

```
游戏创建 → 玩家分配 → 角色分发
       ↓
   夜晚阶段 ────┐
       ↓           │
   白天阶段       │ ← 重复直到胜利条件
       ↓           │
  投票阶段 ────┘
       ↓
   游戏结束
```

### 通信模式

游戏主控和玩家之间的所有通信都是同步基于 HTTP 的：

1. **游戏主控** 发送上下文并请求行动
2. **AI 玩家** 使用 AI 模型处理上下文
3. **AI 玩家** 返回结构化响应（由 Zod 验证）
4. **游戏主控** 处理响应并更新游戏状态
5. **重复** 进行下一个玩家或阶段

## 技术栈

### 前端 (游戏主控)
- **框架**: Vite + React + TypeScript
- **状态管理**: MobX 使用观察者模式
- **样式**: TailwindCSS + Shadcn/ui 组件
- **HTTP 客户端**: 带重试逻辑的自定义 PlayerAPIClient

### 后端 (AI 玩家)  
- **运行时**: Bun (开发) / Node.js (生产)
- **框架**: Express.js 使用 TypeScript
- **AI 集成**: AI SDK 使用 OpenRouter 代理
- **验证**: Zod 模式实现类型安全
- **遥测**: Langfuse 实现 AI 可观测性

### 共享基础设施
- **包管理器**: Bun 使用工作区
- **类型系统**: 使用严格设置的 TypeScript
- **验证**: Zod 模式进行运行时类型检查
- **Monorepo**: 基于工作区的共享依赖

## 关键架构决策

### 1. 分布式玩家架构
- **原因**: 允许独立的扩展和个性隔离
- **优势**: 每个玩家可以有独特的配置和 AI 模型
- **权衡**: 部署更复杂，但具有更好的容错性

### 2. 基于 HTTP 的通信
- **原因**: 简单、无状态、易于调试
- **优势**: 无连接管理或 WebSocket 复杂性
- **权衡**: 延迟高于 WebSockets，但对于回合制游戏足够

### 3. MobX 状态管理
- **原因**: 响应式编程，样板代码少
- **优势**: 自动 UI 更新和计算值
- **权衡**: 有学习曲线，但开发者体验出色

### 4. Zod 模式验证
- **原因**: AI 响应的运行时类型安全
- **优势**: 捕获 AI 幻觉并确保数据一致性
- **权衡**: 额外的验证开销，但对可靠性至关重要

### 5. Langfuse 遥测集成
- **原因**: AI 可观测性和调试能力
- **优势**: 跟踪 AI 性能和决策模式
- **权衡**: 额外的复杂性，但对 AI 系统至关重要

## 可扩展性考虑

### 当前限制
- **单个游戏实例**: 前端同时只能处理一个游戏
- **顺序处理**: 玩家逐个做决定
- **内存状态**: 游戏状态不持久化

### 未来扩展机会
- **多游戏支持**: 基于数据库的游戏状态管理
- **并行处理**: 适用情况下的并发 AI 决策
- **玩家池**: 多个游戏共享玩家服务实例
- **水平扩展**: 玩家服务的负载均衡器

此架构为 AI 驱动的狼人杀游戏提供了坚实的基础，具有清晰的关注点分离、类型安全和整个系统的可观测性。